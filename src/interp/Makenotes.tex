%% Oh Emacs, this is a -*- Makefile -*-, so give me tabs.
\documentclass{article}
\usepackage{axiom}
\begin{document}
\title{\$SPAD/src/interp Makefile}
\author{Timothy Daly \and Gabriel Dos~Reis}
\maketitle
\begin{abstract}
\end{abstract}
\eject
\tableofcontents
\eject
\begin{verbatim}

IMPORTANT: all source file names in this Makefile must be lowercase
  This is for cross-platform compatibility and also makes getting
  them into Lisp much easier at the Makefile level.

\end{verbatim}

\section{The Environment}

We define 3 directories for this build. The first is
{\bf MID} which is where we will put the compiled intermediates.

Since we support separate build tree we are phasing out the old
directory structure and move everything to the current direstory.

The interpreter files are usually written in {\bf boot} \cite{2}.
There are two dialects of {\bf boot}: the old one and a newer one (shoe).
Shoe (new boot) files will be compiled in a {\bf BOOTSYS} image (to
translate from {\bf boot} to Common Lisp.  The old boot files
will be compiled in a {\bf DEPSYS} image.


In order to minimize the size of the Axiom image at load time
we put some of the compiled files into a separate directory
that will be autoloaded on demand. This directory of code
will be shipped with the final system and so it belongs in
the {\bf \$SPAD/mnt} subtree.
<<environment>>=
AUTO=$(axiom_targetdir)/autoload

autoload_objects =

@

We need a raw lisp image that we can use as a base to construct
the other images. This is called {\bf LISPSYS} and is
system-dependent and machine-generated.
It belongs in the {\bf \$SPAD/obj} subtree.
<<environment>>=
LISPSYS= $(axiom_build_bindir)/lisp

@

Most of the interpreter is written in {\bf boot} \cite{2}.
Thus we need a program to translate {\bf boot} to Common
Lisp. The translator for shoe (new boot) is called the {\bf BOOTSYS}
image (because the
translator is written in {\bf boot} and needs to translate
itself to bootstrap the system). This image is assumed to
have been built by a previous step in the make process.
<<environment>>=
BOOTSYS= $(axiom_build_bindir)/bootsys

@

The old boot is translated using {\bf DEPSYS} image.

Also some of the Common Lisp code we compile uses macros which
are assumed to be available at compile time. The {\bf DEPSYS}
image is created to contain the compile time environment
and saved. We pipe compile commands into this environment
to compile from Common Lisp to machine dependent code.
%
<<environment>>=
DEPSYS=	$(axiom_build_bindir)/depsys

depsys_lisp_noncompiled_sources += sys-pkg.lisp nocompil.lisp \
	ncompil.lisp bookvol5.lisp util.lisp

depsys_lisp_compiled_sources += parsing.lisp metalex.lisp bootlex.lisp \
	newaux.lisp preparse.lisp def.lisp metameta.lisp \
	fnewmeta.lisp

depsys_lisp_sources = $(depsys_lisp_noncompiled_sources) \
			$(depsys_lisp_compiled_sources)

@

The {\bf DEP} variable contains the list of files that
will be loaded into {\bf DEPSYS}. Notice that these files
are loaded in interpreted form. We are not concerned about
the compile time performance so we can use interpreted code.
We do, however, care about the macros as these will be
expanded in later compiles. All macros are assumed to be
in this list of files.
<<environment>>=
DEP=	vmlisp.lisp	ggreater.lisp	\
	hash.lisp	bootfuns.lisp	\
	union.lisp	nlib.lisp	\
	macros.lisp	comp.lisp	\
	spaderror.lisp	debug.lisp	\
	spad.lisp	bits.lisp	\
	setq.lisp	property.lisp	\
	foam_l.lisp      \
	axext_l.lisp

depsys_lisp_macro_sources = vmlisp.lisp ggreater.lisp hash.lisp \
	bootfuns.lisp union.lisp nlib.lisp macros.lisp	\
	comp.lisp spaderror.lisp debug.lisp \
	spad.lisp bits.lisp setq.lisp property.lisp \
	foam_l.lisp axext_l.lisp

depsys_lisp_noncompiled_sources += $(depsys_lisp_macro_sources)
depsys_lisp_SOURCES = $(addsuffix .pamphlet, $(depsys_lisp_sources))
@

Once we've compile all of the Common Lisp files we fire up
a clean lisp image called {\bf LOADSYS}, load all of the
final executable code and save it out as {\bf SAVESYS}.
The {\bf SAVESYS} image is copied to the [[$(axiom_target_bindir)]]
subdirectory and becomes the axiom executable image.
<<environment>>=
LOADSYS= $(axiom_build_bindir)/lisp$(EXEEXT)
SAVESYS= $(axiom_build_bindir)/interpsys$(EXEEXT)
AXIOMSYS= $(axiom_target_bindir)/AXIOMsys$(EXEEXT)

@

These are the files that need to be compiled (in {\bf BOOTSYS}),
loaded into a clean lisp image ({\bf LOADSYS}) and saved as
a runnable Axiom interpreter ({\bf SAVESYS}) usually named
{\bf interpsys}. Most of these files
are translated from {\bf boot} to Common Lisp and then
compiled. There are two exceptions, {\bf bootfuns.lisp}
and {\bf setq.lisp}. The {\bf bootfuns.lisp} \cite{3} file
contains forward references for {\bf boot} code. The {\bf setq.lisp}
file contains constant initialization code which gains nothing
by being compiled.

The value of the variable [[AXIOMsys_boot_sources]] is the (currently
partial) list of Boot source files that make up the interpreter.
Similarly, the value of the variable [[AXIOMsys_compiled_lisp_sources]]
is the list of Common Lisp source files that are compiled into
the interpreter.  Notice that some of these files are loaded (\eg{},
interpreted) in [[depsys]].

<<environment>>=
OBJS=	vmlisp.$(FASLEXT)	hash.$(FASLEXT)	\
	bootfuns.lisp	macros.$(FASLEXT)	\
	setq.lisp	\
	astr.$(FASLEXT)	bits.$(FASLEXT)	\
	alql.$(FASLEXT)	buildom.$(FASLEXT)	\
	cattable.$(FASLEXT)				\
	cformat.$(FASLEXT)	cfuns.$(FASLEXT)	\
	clam.$(FASLEXT)	clammed.$(FASLEXT)	\
	comp.$(FASLEXT)	\
	compat.$(FASLEXT)	compress.$(FASLEXT)	\
	cparse.$(FASLEXT)	cstream.$(FASLEXT)	\
	database.$(FASLEXT)	\
	debug.$(FASLEXT)	dq.$(FASLEXT)		\
	fname.$(FASLEXT)	format.$(FASLEXT)	\
	g-boot.$(FASLEXT)	g-cndata.$(FASLEXT)	\
	g-error.$(FASLEXT)	g-opt.$(FASLEXT)	\
	g-timer.$(FASLEXT)	g-util.$(FASLEXT)	\
	ggreater.$(FASLEXT)				\
	hypertex.$(FASLEXT)	i-analy.$(FASLEXT)	\
	i-code.$(FASLEXT)	i-coerce.$(FASLEXT)	\
	i-coerfn.$(FASLEXT)	i-eval.$(FASLEXT)	\
	i-funsel.$(FASLEXT)	bookvol5.$(FASLEXT)	\
	i-intern.$(FASLEXT)	i-map.$(FASLEXT)	\
	i-output.$(FASLEXT)	i-resolv.$(FASLEXT)	\
	i-spec1.$(FASLEXT)				\
	i-spec2.$(FASLEXT)	i-syscmd.$(FASLEXT)	\
	i-toplev.$(FASLEXT)	i-util.$(FASLEXT)	\
	incl.$(FASLEXT)	int-top.$(FASLEXT)	\
	lisplib.$(FASLEXT)	macex.$(FASLEXT)	\
	match.$(FASLEXT)				\
	monitor.$(FASLEXT)	msg.$(FASLEXT)		\
	msgdb.$(FASLEXT)	nci.$(FASLEXT)		\
	newaux.$(FASLEXT)	newfort.$(FASLEXT)	\
	nlib.$(FASLEXT)	nrunfast.$(FASLEXT)	\
	nrungo.$(FASLEXT)	nrunopt.$(FASLEXT)	\
	nruntime.$(FASLEXT)	osyscmd.$(FASLEXT)	\
	packtran.$(FASLEXT)	pathname.$(FASLEXT)	\
	pf2sex.$(FASLEXT)	pile.$(FASLEXT)	\
	posit.$(FASLEXT)	property.lisp	\
	ptrees.$(FASLEXT)	ptrop.$(FASLEXT)	\
	record.$(FASLEXT)				\
	rulesets.$(FASLEXT)	\
	scan.$(FASLEXT)	serror.$(FASLEXT)	\
	server.$(FASLEXT)				\
	setvars.$(FASLEXT)	\
	sfsfun-l.$(FASLEXT)	sfsfun.$(FASLEXT)	\
	simpbool.$(FASLEXT)	slam.$(FASLEXT)	\
	sockio.$(FASLEXT)	spad.$(FASLEXT)	\
	spaderror.$(FASLEXT)				\
	template.$(FASLEXT)	termrw.$(FASLEXT)	\
	trace.$(FASLEXT)	\
	union.$(FASLEXT)       daase.$(FASLEXT)  	\
	fortcall.$(FASLEXT)

AXIOMsys_noncompiled_lisp_sources = bootfuns.lisp nocompil.lisp \
	property.lisp setq.lisp

AXIOMsys_compiled_lisp_sources = bits.lisp \
	bootlex.lisp cfuns.lisp comp.lisp construc.lisp daase.lisp \
	debug.lisp def.lisp fname.lisp fnewmeta.lisp ggreater.lisp \
	hash.lisp macros.lisp metalex.lisp monitor.lisp newaux.lisp \
	nlib.lisp nspadaux.lisp parsing.lisp \
	patches.lisp preparse.lisp \
	sockio.lisp spad.lisp spaderror.lisp \
	union.lisp util.lisp vmlisp.lisp obey.lisp \
	nci.lisp sfsfun-l.lisp \
	axext_l.lisp foam_l.lisp

AXIOMsys_boot_sources = astr.boot alql.boot buildom.boot cattable.boot \
	cformat.boot clam.boot clammed.boot compat.boot compress.boot \
	cparse.boot cstream.boot database.boot dq.boot format.boot \
	g-boot.boot g-cndata.boot g-error.boot g-opt.boot g-timer.boot \
	g-util.boot hypertex.boot i-analy.boot i-code.boot i-coerce.boot \
	i-coerfn.boot i-eval.boot i-funsel.boot i-intern.boot i-map.boot \
	i-output.boot i-resolv.boot i-spec1.boot i-spec2.boot \
	i-syscmd.boot i-toplev.boot i-util.boot incl.boot int-top.boot \
	lisplib.boot macex.boot match.boot msg.boot \
	msgdb.boot newfort.boot nrunfast.boot nrungo.boot nrunopt.boot \
	nruntime.boot osyscmd.boot packtran.boot pathname.boot \
	pf2sex.boot pile.boot posit.boot ptrees.boot ptrop.boot \
	record.boot rulesets.boot scan.boot serror.boot server.boot \
	setvars.boot sfsfun.boot simpbool.boot slam.boot template.boot \
	termrw.boot trace.boot fortcall.boot
@

Before we save the {\bf SAVESYS} image we need to run some
initialization code. These files perform initialization
for various parts of the system. The {\bf patches.lisp} \cite{5}
file contains last-minute changes to various functions and
constants.
<<environment>>=
INOBJS=	varini.$(FASLEXT)	parini.$(FASLEXT)	\
	setvart.$(FASLEXT)	\
        interop.$(FASLEXT)     \
        patches.$(FASLEXT)

@

Certain functions do not need to be in the running system.
If the running image never calls the compiler or does not
use the hypertex browser we will never call the functions
in these files. The code that calls these functions in the
running system will autoload the appropriate files the
first time they are called. Loading the files overwrites
the autoload function call and re-calls the function.
Any subsequent calls will run the compiled code.

The {\bf OPOBJS} list contains files from the old parser. The use of
``old'' is something of a subtle concept as there were several
generations of ``old'' and all meaning of the term is lost.

Notice that the object file [[def.$(FASLEXT)]] appears on both the
[[OPBJS]] and [[TRANOBJS]] lists.  In normal situation, parsing
precedes translation; consequently the file [[def]] is loaded by the
parser, so that it does not need to be reloaded by the translator.
However, it may theoretically be that a translation could happen without
prior parsing (in case someone types in a parse tree for SPAD code).
Consequently, it must be ensured that [[def.]] is still loaded in that
configuration.  In the long term, the autoload machinery need
rethinking.

<<environment>>=
# These are autloaded old parser files
OPOBJS=	${AUTO}/parsing.$(FASLEXT)	${AUTO}/bootlex.$(FASLEXT)	\
        ${AUTO}/def.$(FASLEXT)	\
	${AUTO}/fnewmeta.$(FASLEXT)	${AUTO}/metalex.$(FASLEXT)	\
	${AUTO}/metameta.$(FASLEXT)	\
	${AUTO}/parse.$(FASLEXT)	${AUTO}/postpar.$(FASLEXT)	\
	${AUTO}/preparse.$(FASLEXT)

autoload_objects += $(OPBJS)
@

The {\bf OCOBJS} list contains files from the old compiler. Again,
``old'' is meaningless. These files should probably be autoloaded.
<<environment>>=
OCOBJS=	${AUTO}/apply.$(FASLEXT)	${AUTO}/c-doc.$(FASLEXT)	\
	${AUTO}/c-util.$(FASLEXT)	${AUTO}/profile.$(FASLEXT)	\
	${AUTO}/category.$(FASLEXT)	${AUTO}/compiler.$(FASLEXT)	\
	${AUTO}/define.$(FASLEXT)	${AUTO}/functor.$(FASLEXT)	\
	${AUTO}/info.$(FASLEXT)	${AUTO}/iterator.$(FASLEXT)	\
	${AUTO}/modemap.$(FASLEXT)	${AUTO}/nruncomp.$(FASLEXT)	\
	${AUTO}/package.$(FASLEXT)	${AUTO}/htcheck.$(FASLEXT)

autoload_objects += $(OCOBJS)

@

The {\bf BROBJS} list contains files only used by the hypertex
browser. These files should probably be autoloaded.
<<environment>>=
BROBJS=	${AUTO}/bc-matrix.$(FASLEXT)				\
	${AUTO}/bc-misc.$(FASLEXT)	${AUTO}/bc-solve.$(FASLEXT)	\
	${AUTO}/bc-util.$(FASLEXT)				\
	${AUTO}/ht-util.$(FASLEXT)	${AUTO}/htsetvar.$(FASLEXT)	\
	${AUTO}/ht-root.$(FASLEXT)	\
	${AUTO}/br-con.$(FASLEXT)	\
	${AUTO}/br-data.$(FASLEXT)	${AUTO}/showimp.$(FASLEXT)    \
	${AUTO}/br-op1.$(FASLEXT)	${AUTO}/br-op2.$(FASLEXT)	\
	${AUTO}/br-search.$(FASLEXT)	${AUTO}/br-util.$(FASLEXT)	\
	${AUTO}/topics.$(FASLEXT)     ${AUTO}/br-prof.$(FASLEXT)    \
	${AUTO}/br-saturn.$(FASLEXT)

autoload_objects += $(BFOBJS)

@
The {\bf TRANOBJS} list contains files used by Spad to Aldor convertor.
The files probably are also used by the {\bf boot}
to Common Lisp translator and are probably never used by anyone
but the developers.

When a user requests converting a file from Spad to Aldor the
function
[[spad2AsTranslatorAutoloadOnceTrigger]] is called triggering
load of this group of files. Loading [[$TRANOBJS]] in turn replaces
many compiler functions by versions contain in this files.
 These files should probably be autoloaded
(at least [[${AUTO}/wi1.$(FASLEXT)]] and [[${AUTO}/wi2.$(FASLEXT)]]
(which replace compiler functions) {\em must} be autoloaded).
<<environment>>=
TRANOBJS= ${AUTO}/wi1.$(FASLEXT) ${AUTO}/wi2.$(FASLEXT) ${AUTO}/pspad1.$(FASLEXT) \
	  ${AUTO}/pspad2.$(FASLEXT) ${AUTO}/mark.$(FASLEXT) ${AUTO}/nspadaux.$(FASLEXT) \
	  ${AUTO}/def.$(FASLEXT)

autoload_objects += $(TRANOBJS)

@

The {\bf ASCOMP} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files should probably be autoloaded.
<<environment>>=
ASCOMP= hashcode.$(FASLEXT) as.$(FASLEXT) \
	foam_l.$(FASLEXT) axext_l.$(FASLEXT)

@
The {\bf ASAUTO} list contains files used by the {\bf Aldor}
\cite{5} compiler. These files are autoloaded as needed.
<<environment>>=
ASAUTO= ${AUTO}/ax.$(FASLEXT)

autoload_objects += $(ASAUTO)
@

Axiom versions are given as a string of the form:
"Sunday September 21, 2003 at 20:38:05 "
which describe the day, date, and time of the build.
This is used for reporting bugs. It is only partially useful
in identifying which source code was used. Ideally we could create
a tar file of all of the date/time stamps of all of the source files
and use the MD5 hash of that file as the version stamp. Ultimately
though, this would be chasing the elusive "perfect information" idea.

A new variable [[boot::*build-version*]] is set here and used by the
[[yearweek]] function to display the version number of the Axiom build.
This information is set by hand in the top level Makefile.
<<environment>>=
TIMESTAMP=$(axiom_targetdir)/timestamp
YEARWEEK=(progn (setq timestamp "${TIMESTAMP}") (setq boot::*build-version* "${VERSION}") (yearweek))

@
The {\bf .PRECIOUS} setting will keep make from deleting these
images if the build is stopped. Since once they are built they
are likely to be useable we don't need to redo the work if they
exist.
<<environment>>=

.PRECIOUS:	${DEPSYS}
.PRECIOUS:	${SAVESYS}
.PRECIOUS:	${AXIOMSYS}

@

\section{The warm.data file}

This is a file of commands that will be loaded into interpsys
at the last minute. It execute functions that will likely be
used in a running system so all of the required routines will
be in the lisp image thus minimizing their startup time.

\section{Building SAVESYS and AXIOMSYS}

<<savesys>>=
${SAVESYS} ${AXIOMSYS}: makeint.lisp \
    ${DEPSYS} ${OBJS}  bookvol5.$(FASLEXT) util.$(FASLEXT) \
    nocompil.lisp sys-pkg.lisp \
    ${OCOBJS} ${OPOBJS} ${BROBJS} \
    database.date ${INOBJS} ${ASCOMP} ${ASAUTO} \
    ${NAGBROBJS} ${TRANOBJS} \
    ${LOADSYS} \
    $(axiom_targetdir)/algebra/exposed.$(FASLEXT) \
    $(axiom_src_datadir)/doc/msgs/s2-us.msgs \
    ../algebra/warm.data

makeint.lisp:
	@ echo 5 invoking make in `pwd` with parms:
	@ echo LSP= ${LSP}
	@ echo PART= ${PART}
	@ echo SRC= $(axiom_src_srcdir)
	@ echo LISP=${LISP} BYE=${BYE}
	$(mkinstalldirs) $(axiom_target_datadir)/msgs
	$(INSTALL_DATA) $(axiom_src_datadir)/doc/msgs/s2-us.msgs \
		 $(axiom_target_datadir)/msgs
	@ echo '${PROCLAIMS}' > makeint.lisp
	@ echo '(load "nocompil.lisp")' >> makeint.lisp
	@ echo '(load "util")' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ touch ${TIMESTAMP}
	@ echo '${YEARWEEK}' >> makeint.lisp
	@ echo '(build-interpsys (append (quote ($(patsubst %, "%", ${OBJS}))) (quote ($(patsubst %, "%", ${ASCOMP}))) (quote ($(patsubst %, "%", ${INOBJS})))) (quote ($(patsubst %, "$(BASE)%", ${OPOBJS}))) (quote ($(patsubst %, "$(BASE)%", ${OCOBJS}))) (quote ($(patsubst %, "$(BASE)%", ${BROBJS}))) (quote ($(patsubst %, "$(BASE)%", ${TRANOBJS}))) (quote ($(patsubst %, "$(BASE)%", ${NAGBROBJS}))) (quote ($(patsubst %, "$(BASE)%", ${ASAUTO})))  "${AXIOM}")' >> makeint.lisp
	@ echo '(in-package "BOOT")' >> makeint.lisp
	@ echo '(load "../algebra/warm.data")' >> makeint.lisp
	@ echo '(|clearClams|)' >> makeint.lisp
	@ echo '#+:akcl (setq compiler::*suppress-compiler-notes* t)' >> makeint.lisp
	@ echo '#+:akcl (si::gbc-time 0)' >> makeint.lisp

${SAVESYS}:
	echo '(load "makeint.lisp") (VMLISP::reclaim)' \
	     '(setf BOOT::|$$createLocalLibDb| nil)' \
	     '(BOOT::spad-save "$(BASE)$@" t)' | ${LISPSYS}
	@ echo 6 ${SAVESYS} created
@

\section{Building SAVESYS and AXIOMSYS}

We want to cache database data in the final image, so we dump it only
after databases are build (triggered from \File{etc/Makefile.pamphlet}).
Note that having dependency on databases is not enough, since databases
are re-generated after leaving \File{interp/} directory.

For [[gcl]] we need to reset [[compiler::*default-system-p*]] to [[nil],
otherwise the dumped image would depend on compiler file [[cmpinclude.h]]
which we do not install.

<<axiomsys>>=
.PHONY: all-axiomsys

all-axiomsys: ${AXIOMSYS}

${AXIOMSYS}:
	echo '(load "makeint.lisp") (VMLISP::reclaim)' \
	   '#+:gcl(setf compiler::*default-system-p* nil)' \
	   '#+:gcl(compiler::emit-fn nil)' \
           '(setq *load-verbose* nil)' \
           '#+:clisp(setf custom:*suppress-check-redefinition* t)' \
	   '(BOOT::spad-save "$(BASE)$@" t)' \
             | DAASE="$(BASE)$(axiom_targetdir)" ${LISPSYS}
	@ echo 6a ${AXIOMSYS} created
@

\subsection{Regular rules}

Most of rules is very regular, however there are files which need
different handling.  We handle generic case using  pattern rules with
explicit list of files.  All other files are handled by different rules.
We prefer pattern rules here over implicit rules because we do not
want to rules beeing used by accident.

<<Regular rules>>=

AUTO_from_IN=\
 apply bootlex def fnewmeta metalex metameta parsing preparse \
 c-util category \
 c-doc compiler profile define functor info iterator modemap \
 nruncomp package parse postpar bc-matrix bc-misc bc-solve \
 bc-util ht-util htsetvar ht-root htcheck ax br-con br-search \
 br-op1 br-op2 br-data br-util br-saturn topics br-prof nspadaux \
 showimp

$(addprefix $(AUTO)/, $(addsuffix .$(FASLEXT), $(AUTO_from_IN))): \
   $(AUTO)/%.$(FASLEXT) : %.$(FASLEXT)
	cp $< $@

IN_from_MID=\
 apply as ax bc-matrix bc-misc bc-solve bc-util br-con br-data \
 br-op1 br-op2 br-prof br-saturn br-search br-util buildom \
 category cattable c-doc clammed compat compiler compress c-util \
 database define format fortcall functor g-cndata g-error g-opt \
 g-timer hashcode htcheck ht-root htsetvar ht-util hypertex \
 i-analy i-code i-coerce i-coerfn i-eval i-funsel \
 i-intern interop i-map info i-output i-resolv i-spec1 i-spec2 \
 i-syscmd iterator i-toplev i-util lisplib match modemap msgdb \
 newfort \
 nruncomp nrunfast nrungo nruntime nrunopt package pathname \
 profile record rulesets server setvars setvart simpbool \
 template termrw topics trace

$(addsuffix .$(FASLEXT), $(IN_from_MID)): \
    %.$(FASLEXT) : %.clisp
	@ echo 10 making $@ from $<
	echo '(progn  (compile-file "$<" :output-file "$@") (${BYE}))' \
	     | ${DEPSYS}

AUTO_from_MID=\
mark pspad1 pspad2 wi1 wi2

$(addprefix $(AUTO)/, $(addsuffix .$(FASLEXT), $(AUTO_from_MID))): \
    $(AUTO)/%.$(FASLEXT) : %.clisp
	@ echo 10 making $@ from $<
	echo '(progn  (compile-file "$<" :output-file "$(notdir $@)")' \
	     ' (${BYE}))' | ${DEPSYS}
	mv "$(notdir $@)" $@

@


\section{The databases}
\begin{verbatim}
 autoload dependencies

 if you are adding a file which is to be autoloaded the following step
 information is useful:
  there are 2 cases:
   1) adding files to currently autoloaded parts
      (as of 2/92: browser old parser and old compiler)
   2) adding new files
   case 1:
     a) you have to add the file to the list of files currently there
        (e.g. see BROBJS above)
     b) add an autolaod rule
        (e.g. ${AUTO}/parsing.$(FASLEXT): parsing.$(FASLEXT))
     c) edit util.lisp to add the 'external' function (those that
        should trigger the autoload
   case 2:
     build-interpsys (in util.lisp) needs an extra argument for the
     new autoload things and several functions in util.lisp need hacking.

 database.date is a marker file used to force a rebuild of interpsys if the
 database is rebuilt (src/algebra/Makefile).

\end{verbatim}
<<databases>>=

$(axiom_targetdir)/algebra/exposed.$(FASLEXT) : exposed.lsp ${DEPSYS}
	@ echo 616 making $@ from exposed.lsp
	echo '(progn  (compile-file "exposed.lsp" :output-file' \
	      ' "$(BASE)$(axiom_targetdir)/algebra/exposed.$(FASLEXT)") (${BYE}))' \
		| ${DEPSYS}

database.date:
	@ echo 617 the database was updated...remaking interpsys
	touch database.date

@

\section{The Makefile}
<<*>>=

subdir = src/interp/

<<environment>>

.SUFFIXES:
.SUFFIXES: .boot .clisp .lisp .pamphlet

.PHONY: all all-ax all-depsys all-interpsys all-axiomsys

all: all-ax

all-ax: stamp
	@echo finished $(srcdir)

stamp:  $(AUTO) remove-stamp build-images
	$(STAMP) stamp

.PHONY: remove-stamp
remove-stamp:
	-rm -f stamp

.PHONY: build-images
build-images: remove-stamp all-interpsys

all-interpsys: all-depsys
	$(mkinstalldirs) $(AUTO)
	$(MAKE) $(SAVESYS)

all-axiomsys: all-depsys
	$(MAKE) $(AXIOMSYS)

all-depsys: $(DEPSYS)

clean:
	@echo 619 cleaning $(builddir)

<<extract source codes>>

mostlyclean-local:
	rm -f *.fn *.data *.o

clean-local: mostlyclean-local
	rm -f *.clisp *.lsp *.boot
	rm -f \
	axext_l.lisp   def.lisp       metalex.lisp   parsing.lisp \
	spad.lisp      bits.lisp      fname.lisp     metameta.lisp \
	patches.lisp   sys-pkg.lisp   bookvol5.lisp  fnewmeta.lisp \
	monitor.lisp   preparse.lisp  union.lisp     bootfuns.lisp \
	foam_l.lisp    nci.lisp       proclaims.lisp \
	bootlex.lisp   ggreater.lisp  newaux.lisp    property.lisp \
	util.lisp      cfuns.lisp     hash.lisp      nlib.lisp \
	setq.lisp      vmlisp.lisp    comp.lisp      \
	nocompil.lisp  sfsfun-l.lisp  daase.lisp     macros.lisp \
	nspadaux.lisp  sockio.lisp    debug.lisp     makedep.lisp \
	spaderror.lisp

distclean-local: clean-local

<<savesys>>
<<depsys>>
<<axiomsys>>
<<databases>>

<<Regular rules>>

<<bookvol5.o (OUT from MID)>>
<<bookvol5.lisp (MID from IN)>>

<<newaux.o (OUT from MID)>>
<<newaux.lisp (MID from IN)>>

<<warm.data.stanza>>

<<DVI from pamphlet>>

@
\end{document}
